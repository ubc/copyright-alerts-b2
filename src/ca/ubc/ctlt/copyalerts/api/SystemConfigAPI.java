package ca.ubc.ctlt.copyalerts.api;

import java.io.BufferedReader;
import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.quartz.JobDetail;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import org.quartz.Trigger;
import org.quartz.UnableToInterruptJobException;
import org.quartz.impl.StdSchedulerFactory;

import blackboard.cms.filesystem.CSContext;
import blackboard.cms.filesystem.CSDirectory;
import blackboard.cms.filesystem.CSEntry;
import blackboard.cms.filesystem.CSEntryMetadata;
import blackboard.cms.filesystem.CSFile;
import blackboard.platform.plugin.PlugInException;
import static org.quartz.JobBuilder.*;
import static org.quartz.TriggerBuilder.*;
import static org.quartz.CronScheduleBuilder.*;

import ca.ubc.ctlt.copyalerts.SavedConfiguration;
import ca.ubc.ctlt.copyalerts.indexerjobs.CSIndexJob;

public class SystemConfigAPI extends HttpServlet
{

	/** Autogenerated serial */
	private static final long serialVersionUID = 1738736327585377900L;
	
	private JobDetail indexJob;
	private Trigger indexTrigger;
	private Scheduler scheduler = null;
	private SavedConfiguration config = new SavedConfiguration();

	/** 
	 * Convenience method that can be overridden to do stuff when this servlet gets placed into service.
	 */
	@Override
	public void init() throws ServletException
	{
		try
		{
			config.load();
			updateScheduler();
		} catch (SchedulerException e)
		{
			throw new ServletException(e);
		} catch (PlugInException e)
		{
			throw new ServletException(e);
		} catch (IOException e)
		{
			throw new ServletException(e);
		}
	}

	/* (non-Javadoc)
	 * @see javax.servlet.GenericServlet#destroy()
	 */
	@Override
	public void destroy()
	{
		try
		{
			System.out.println("Shutting down scheduler");
			scheduler.shutdown(true);

			// Even though scheduler waits for threads to end, it still needs an additional second or so
			// before it completely unloads itself
			try
			{
				Thread.sleep(1000);
			} catch (InterruptedException e)
			{
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		} catch (SchedulerException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException
	{
		/*
		System.out.println("Why not working?");
		CSContext ctx = CSContext.getContext();
		// Get a list of files to look for metadata on
		CSEntry root = ctx.findEntry("/courses/CL.UBC.MATH.101.201.2012W2.13204");
		CSDirectory dir = (CSDirectory) root; // we know it's a directory, so cast it
		System.out.println("ls directory: " + dir.getDirectoryContents().size());
		for (CSEntry e : dir.getDirectoryContents())
		{
			System.out.println(e.getFullPath());
			if (e instanceof CSFile)
			{
				System.out.println("Is File");
				CSFile f = (CSFile) e;
				CSEntryMetadata meta = f.getCSEntryMetadata();
				System.out.println("With Permission: " + meta.getStandardProperty("a_16e5ec38cbd34fd693afb019806a3901"));
				System.out.println("Fair Dealing: " + meta.getStandardProperty("a_2c3b588ee28a4cbab06b9867c094b533"));
				System.out.println("Public Domain: " + meta.getStandardProperty("a_24a6cd178f3d4495b3c67cf1ea805f9e"));
				System.out.println("Other: " + meta.getStandardProperty("a_b6072bc76cbf4458b3a8da39aeb8fd81"));
			}
		}
		  
		// pass on request to index.jsp
		RequestDispatcher dispatcher = request.getRequestDispatcher("/WEB-INF/view/default.jsp");
		if (dispatcher != null) 
		{
			dispatcher.forward(request, response);
		}
		*/
		
		String path = request.getPathInfo();
		System.out.println("Path Info: " + path);
		if (path.equals("/schedule"))
		{ // returns a json map of all the schedule configuration values
			response.setContentType("application/json");
			response.setCharacterEncoding("UTF-8");
			response.getWriter().write(config.toJson());
		}
		else if (path.equals("/status"))
		{ // return a json map of the current execution status
		}
		else if (path.equals("/status/stop"))
		{ // tell the currently executing job to stop
			try
			{
				scheduler.interrupt(indexJob.getKey());
			} catch (UnableToInterruptJobException e)
			{
				throw new ServletException(e);
			}
		}
		else
		{
			response.sendError(404);
		}
	}

	/**
	 * Save the new configuration settings
	 */
	@Override
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException
	{
		System.out.println("Path Info: " + request.getPathInfo());
		if (request.getPathInfo().equals("/schedule"))
		{
			// read json response body, have to read this manually cause httpservlet doesn't support json, heh
			StringBuilder sb = new StringBuilder();
		    BufferedReader br = request.getReader();
		    String str = "";
		    while( (str = br.readLine()) != null ){
		        sb.append(str);
		    } 
		    
		    try
			{
			    // parse the json string and save the new config
			    config.fromJson(sb.toString());
				updateScheduler();
			} catch (SchedulerException e)
			{
				System.out.println("Unable to update scheduler.");
				response.sendError(500);
				return;
			} catch (PlugInException e)
			{
				System.out.println("Unable to update configuration.");
				response.sendError(500);
				return;
			}
		    // return the new config to caller
		    doGet(request, response);
		}
		else
		{
			response.sendError(404, "Unrecognized API Call");
		}
	}
	
	/**
	 * Create or disable the scheduler as needed according to configuration.
	 * 
	 * Exceptions are just going to be tossed back up the stack. I'm not exactly sure what would cause exceptions, so hopefully we don't get any, lol.
	 * The server will just return 500s on exception.
	 * 
	 * Need a scheduler that can
	 * - confine execution to a time period
	 * - can resume execution after that time period
	 * - can check to see if it's being executed in another thread somehow and won't try to run if it finds another version of itself running
	 * - Original plan calls for leader elections to decide which node to run indexing, but manual configuration by admins with default should suffice. 
	 * @throws SchedulerException 
	 */
	private void updateScheduler() throws SchedulerException
	{
		// create and configure scheduler according to configuration
		// 1. we have no prior scheduler enabled, need to create it
		// 2. we already have a prior scheduler, need to modify its settings
		System.out.println("CRON: " + config.getQuartzCron());
		if (scheduler == null)
		{ // need to create new scheduler
			scheduler = StdSchedulerFactory.getDefaultScheduler();
			// create a job
			indexJob = newJob(CSIndexJob.class)
					.withIdentity("myJob", "group1")
					.build();
			// create a trigger that runs on the cron configuration
			indexTrigger = newTrigger()
			        .withIdentity("trigger1", "group1")
			        .withSchedule(cronSchedule(config.getQuartzCron()))
			        .build();
			
			// combine job and trigger and run it
			scheduler.scheduleJob(indexJob, indexTrigger);
		}
		else 
		{ // need to modify existing scheduler settings to the new settings
			Trigger trigger = newTrigger()
			        .withIdentity("trigger1", "group1")
			        .withSchedule(cronSchedule(config.getQuartzCron()))
			        .build();
			scheduler.rescheduleJob(indexTrigger.getKey(), trigger);
			indexTrigger = trigger;
		}

		if (config.isEnable() && scheduler.isInStandbyMode())
		{ // allow trigger firing if needed
			System.out.println("Start scheduling");
			scheduler.start();
		}
		else if (!config.isEnable() && scheduler.isStarted())
		{ // stop trigger firing if needed
			System.out.println("Pause scheduling");
			scheduler.standby();
		}

	}
	
}
